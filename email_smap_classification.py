# -*- coding: utf-8 -*-
"""email smap classification

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12slanNM_vK4OKVL4uz-U5ESMqZZUm4zg

###import libraries
"""

# Commented out IPython magic to ensure Python compatibility.
# linear algebra
import numpy as np

# data processing
import pandas as pd

# data visualization
import seaborn as sns
# %matplotlib inline
from matplotlib import pyplot as plt
from matplotlib import style
from sklearn.metrics import confusion_matrix

# Algorithms
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import GaussianNB,MultinomialNB,BernoulliNB
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.pipeline import Pipeline

#read the CSV file
df=pd.read_csv("/content/email.csv")

df.head()

df.shape

df.info()

df.describe()

# Creating the 'spam' column: 1 if category is 'spam', 0 otherwise
df['spam'] = df['Category'].apply(lambda x: 1 if x == 'spam' else 0)

df.head()

input = df['Message']
output = df['spam']

#split train and test data
x_train, x_test, y_train, y_test= train_test_split(input, output, test_size= 0.3)

"""##Naive Bayes Algorithm"""

#Defineing Naive Baised
clf_NaiveBaised= Pipeline([
    ('vectorizer', CountVectorizer()),
    ('nd', MultinomialNB())
])

#Fiting the algorithm
clf_NaiveBaised.fit(x_train,y_train)

#Make prediction on X_test
y_pred_NB=clf_NaiveBaised.predict(x_test)

conf_mat_NB=confusion_matrix(y_test, y_pred_NB)

#plot confusion matrix
plt.figure(figsize=(10,8))
sns.heatmap(conf_mat_NB,annot=True,fmt='d')

naive_accuracy=accuracy_score(y_test,y_pred_NB)
naive_accuracy

"""##SVM Classifier"""

#create claassifier for svm
clf_svm= Pipeline([
    ('vectorizer', CountVectorizer()),
    ('svc', SVC(kernel="rbf",C=1000,gamma=0.001))
])

clf_svm.fit(x_train,y_train)

y_pred_SVM=clf_svm.predict(x_test)

#plot confussion matrix
conf_mat_SVM=confusion_matrix(y_test, y_pred_SVM)

plt.figure(figsize=(10,8))
sns.heatmap(conf_mat_SVM,annot=True,fmt='d')

svm_accuracy=accuracy_score(y_test,y_pred_SVM)
svm_accuracy

"""##k nearest neighbor classifier"""

clf_knn= Pipeline([
    ('vectorizer', CountVectorizer()),
    ('knn', KNeighborsClassifier(n_neighbors=3))
])

clf_knn.fit(x_train,y_train)

y_pred_KNN=clf_knn.predict(x_test)

#plot confussion matrix

conf_mat_KNN=confusion_matrix(y_test, y_pred_KNN)

plt.figure(figsize=(10,8))
sns.heatmap(conf_mat_KNN,annot=True,fmt='d')

knn_acc=accuracy_score(y_test,y_pred_KNN)
knn_acc

"""##Decision Tree Classifier"""

clf_DecisionTree= Pipeline([
    ('vectorizer', CountVectorizer()),
    ('dt',DecisionTreeClassifier())
])

clf_DecisionTree.fit(x_train,y_train)

y_pred_DT=clf_DecisionTree.predict(x_test)

#plot confusion matrix
conf_mat_DT=confusion_matrix(y_test, y_pred_DT)

plt.figure(figsize=(10,8))
sns.heatmap(conf_mat_DT,annot=True,fmt='d')

dt_acc=accuracy_score(y_test,y_pred_DT)
dt_acc

"""##Random Forest Classifier"""

clf_rf= Pipeline([
    ('vectorizer', CountVectorizer()),
    ('rf', RandomForestClassifier(n_estimators=100))
])

clf_rf.fit(x_train,y_train)

y_pred_RF=clf_rf.predict(x_test)

#plot confusion matrix
conf_mat_RF=confusion_matrix(y_test, y_pred_RF)

plt.figure(figsize=(10,8))
sns.heatmap(conf_mat_RF,annot=True,fmt='d')

rf_acc=accuracy_score(y_test,y_pred_RF)
rf_acc

"""#finished basic concept of our algorithms

##Compareing Accrucy of those algorithm
"""

menMeans = np.array([naive_accuracy,svm_accuracy,knn_acc,dt_acc,rf_acc])*100
ind = ['Naive Bayes','SVM','KNN','DT','Random Forest']
fig, ax = plt.subplots(figsize = (8,3))
ax.bar(ind,menMeans,width=0.2,color ='red')
for index,data in enumerate(menMeans):
    plt.text(x=index , y =data+1 , s="{:.2f}".format(data) , fontdict=dict(fontsize=7))
plt.tight_layout()
plt.show()

"""#Thank you"""